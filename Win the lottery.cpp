/*某机构举办球票大奖赛。获奖选手有机会赢得若干张球票。

主持人拿出 N 张卡片（上面写着1...N 的数字），打乱顺序，排成一个圆圈。

你可以从任意一张卡片开始顺时针数数: 1,2,3 ...

如果数到的数字刚好和卡片上的数字相同，则把该卡片收入囊中，从下一个卡片重新数数。

直到再无法收获任何卡片，游戏结束。囊中卡片数字的和就是赢得球票的张数。

比如：

卡片排列是：1 2 3

我们从 1 号卡开始数，就把 1 号卡拿走。再从 2 号卡开始，但数的数字无法与卡片对上，很快数字越来越大，不可能再拿走卡片了。因此这次我们只赢得了 1 张球票。

还不算太坏！如果我们开始就傻傻地从 2 或 3 号卡片数起，那就一张卡片都拿不到了。

如果运气好，卡片排列是 2 1 3，那我们可以顺利拿到所有的卡片！

本题的目标：已知顺时针卡片序列，随便你从哪里开始数，求最多能赢多少张球票（就是收入囊中的卡片数字之和）*/
#include<stdio.h>
int main()
{
    int N,i,j,max=0,count[100]={0};
    int card[100],flag[100]={0};
    int num,pos,sum[100]={0};
    scanf("%d",&N);
    for(i=1;i<=N;i++)
    {
        scanf("%d",&card[i]);
    }
    for(i=1;i<=N;i++)
    {
        pos=i;
        num=1; 
        while(1)
        {
            if(flag[pos])
            {    
                pos++;
            }
            else
            {
                if(num==card[pos])
                {
                    sum[i]+=card[pos];
                    count[i]++;
                    flag[pos]=1;
                    num=1;
                }
                else
                {
                    num++;
                    pos++;    
                }    
            }    
            if(pos>N)
                pos=1;
            if(num>N||count[i]==N)
            {
                for(j=1;j<=N;j++)
                {
                    flag[j]=0;
                }
                break;
            }
        }
    }
        for(i=1;i<=N;i++)
        {
            if(sum[i]>max)
                max=sum[i];
        }
        printf("%d ",max); 
    return 0;
}
